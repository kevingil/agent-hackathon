from pydantic import BaseModel, Field, Json
from typing import Any, Dict, List, Literal, Optional, Union


class DecideResponse(BaseModel):
    thoughts: list[str] = Field(description="List of thoughts")
    selected_tools: list[dict] = Field(description="List of selected tools")
    
    @classmethod
    def render(
        cls,
        tools: list[dict],
        question: str,
        called_tools: list[dict],
        **kwargs
    ) -> str:
        """Render the prompt for deciding which tools to use."""
        tool_descriptions = "\n".join(
            f"- {tool['name']}: {tool.get('description', 'No description')}"
            for tool in tools
        )
        
        called_tools_str = "No tools have been called yet."
        if called_tools:
            called_tools_str = "\n".join(
                f"- {tool.get('name', 'Unknown')}: {tool.get('result', 'No result')}"
                for tool in called_tools
            )
        
        return f"""
        You are an AI assistant that helps decide which tools to use to answer a question.
        
        Available tools:
        {tool_descriptions}
        
        Previously called tools and their results:
        {called_tools_str}
        
        Question: {question}
        
        Based on the question and previous tool results, which tools should be used next?
        Respond with a JSON object containing 'thoughts' and 'selected_tools'.
        """


class CalledToolHistoryResponse(BaseModel):
    question: str = Field(description="The question to answer")
    tools: List[dict] = Field(description="List of tools")
    called_tools: List[dict] = Field(description="List of called tools")


class PlannerTask(BaseModel):
    """Represents a single task generated by the Planner."""

    id: int = Field(description="Sequential ID for the task.")
    description: str = Field(
        description="Clear description of the task to be executed."
    )
    assigned_agent: str = Field(description="The agent responsible for the task")
    status: (
        Any
        | Literal[
            "input_required",
            "completed",
            "error",
            "pending",
            "incomplete",
            "todo",
            "not_started",
        ]
        | None
    ) = Field(description="Status of the task", default="input_required")


class Plan(BaseModel):
    """Output schema for the Planner Agent."""

    original_query: str = Field(description="The original user query for context.")
    description: str = Field(description="Clear description of the .")
    tasks: list[PlannerTask] = Field(
        description="A list of tasks to be executed sequentially."
    )


class ToolFunction(BaseModel):
    """Represents a function call from the LLM."""
    name: str = Field(description="The name of the function to call.")
    arguments: str = Field(description="The arguments to call the function with, as a JSON string.")


class ToolCall(BaseModel):
    """Represents a tool call request from the LLM."""
    id: str = Field(description="The ID of the tool call.")
    type: str = Field(default="function", description="The type of the tool call.")
    function: ToolFunction = Field(description="The function details.")


class ToolResult(BaseModel):
    """Represents the result of a tool execution."""
    tool_call_id: str = Field(description="The ID of the tool call this result is for.")
    result: str = Field(description="The result of the tool execution.")
    is_error: bool = Field(default=False, description="Whether the tool execution resulted in an error.")


class Plan(BaseModel):
    """Output schema for the Planner Agent with tool support."""
    response: str = Field(description="The agent's response to the user.")
    tool_calls: List[ToolCall] = Field(
        default_factory=list,
        description="List of tool calls to execute, if any."
    )


class ResponseFormat(BaseModel):
    """Respond to the user in this format."""

    status: Literal["input_required", "completed", "error"] = "input_required"
    question: str = Field(
        description="Input needed from the user to generate the code search plan"
    )
    content: Plan = Field(
        description="List of tasks when the code search plan is generated"
    )


class ServerConfig(BaseModel):
    """Server Confgiguration."""

    host: str
    port: int
    transport: str
    url: str
